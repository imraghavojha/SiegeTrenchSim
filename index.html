<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fort Siege Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #f1f5f9; /* slate-100 */
        }
        .p5Canvas {
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .control-panel {
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .btn-active {
            background-color: #0284c7; /* sky-600 */
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15) inset;
        }
        .btn-danger-active {
             background-color: #dc2626; /* red-600 */
             color: white;
             box-shadow: 0 2px 4px rgba(0,0,0,0.15) inset;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #e2e8f0; /* slate-200 */
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #0ea5e9; /* sky-500 */
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #0ea5e9;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="text-slate-800">

    <div id="app-container" class="w-full h-screen flex flex-col p-4 gap-4">
        <!-- Header -->
        <header class="text-center flex-shrink-0">
            <h1 class="text-3xl md:text-4xl font-bold">Fort Siege Simulator</h1>
            <p class="text-sm md:text-base text-slate-500 mt-1">Design defenses, place artillery, and test your strategy.</p>
        </header>

        <!-- Main Content -->
        <div class="flex-grow flex flex-col md:flex-row gap-4 min-h-0">
            <!-- Control Panel -->
            <aside id="controls" class="w-full md:w-72 lg:w-80 p-4 border border-slate-200 rounded-lg shadow-lg control-panel flex-shrink-0 flex flex-col gap-6 overflow-y-auto">
                
                <div>
                    <h2 class="text-lg font-semibold border-b border-slate-300 pb-2 mb-3">Fortress</h2>
                    <select id="fort-select" class="w-full p-2 border border-slate-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500">
                        <option value="square">Square Keep</option>
                        <option value="circular">Circular Tower</option>
                        <option value="star">Star Fort</option>
                        <option value="custom">Custom (Draw Walls)</option>
                    </select>
                </div>

                <div>
                    <h2 class="text-lg font-semibold border-b border-slate-300 pb-2 mb-3">Tools</h2>
                    <div class="flex flex-wrap gap-2">
                        <button id="tool-select" class="p-2 border rounded-md btn flex-grow">Select</button>
                        <button id="tool-trench" class="p-2 border rounded-md btn flex-grow">Dig Trench</button>
                        <button id="tool-wall" class="p-2 border rounded-md btn flex-grow">Build Wall</button>
                        <button id="tool-cannon" class="p-2 border rounded-md btn flex-grow">Place Cannon</button>
                         <button id="tool-water" class="p-2 border rounded-md btn flex-grow">Place Water</button>
                        <button id="tool-remove" class="p-2 border rounded-md btn flex-grow bg-red-100 border-red-200 hover:bg-red-200">Remove</button>
                    </div>
                    <div class="mt-4">
                        <label for="algorithm-select" class="text-sm font-medium">Trench Algorithm:</label>
                        <select id="algorithm-select" class="w-full p-2 mt-1 border border-slate-300 rounded-md bg-white focus:outline-none focus:ring-2 focus:ring-sky-500">
                            <option value="sapperTrench">Sapper Trench (A*)</option>
                            <option value="directApproach">Direct Approach</option>
                        </select>
                        <button id="generate-trench-button" class="w-full mt-2 p-2 border rounded-md btn bg-slate-200">Generate Trench</button>
                    </div>
                </div>
                
                <div>
                    <h2 class="text-lg font-semibold border-b border-slate-300 pb-2 mb-3">Artillery Settings</h2>
                    <p class="text-xs text-slate-500 mb-3">0&deg; is right, -90&deg; is up. Adjust before placing or modifying.</p>
                    <div class="space-y-4">
                        <div>
                            <label for="cannon-angle" class="block text-sm font-medium">Angle: <span id="angle-value">0</span>&deg;</label>
                            <input type="range" id="cannon-angle" min="-180" max="180" value="0" class="w-full">
                        </div>
                        <div>
                            <label for="cannon-power" class="block text-sm font-medium">Power: <span id="power-value">50</span></label>
                            <input type="range" id="cannon-power" min="10" max="100" value="50" class="w-full">
                        </div>
                    </div>
                </div>

                <div class="flex-grow"></div>

                <div>
                    <div class="flex flex-col gap-2">
                         <button id="fire-button" class="p-3 bg-red-600 text-white rounded-md font-bold btn hover:bg-red-700">FIRE ALL CANNONS</button>
                         <button id="reset-button" class="p-2 bg-slate-500 text-white rounded-md btn hover:bg-slate-600">Reset All</button>
                    </div>
                </div>

                <div class="flex-shrink-0">
                    <h2 class="text-lg font-semibold border-b border-slate-300 pb-2 mb-3">Battle Report</h2>
                    <div id="info-panel" class="p-3 bg-slate-100 rounded-md h-24 text-sm text-slate-700 overflow-y-auto border border-slate-200">
                        Welcome! Select a fort and design your defenses.
                    </div>
                </div>

            </aside>

            <!-- Simulation Canvas -->
            <main id="canvas-container" class="flex-grow relative rounded-lg bg-slate-800 flex items-center justify-center min-h-0">
                <!-- p5.js canvas will be inserted here -->
            </main>
        </div>
    </div>

    <script>
        // --- Global Variables and State ---
        let sketch;
        let canvas;
        
        const state = {
            currentTool: 'select',
            fortType: 'square',
            walls: [],
            trenches: [],
            water: [],
            cannons: [],
            cannonballs: [],
            isDrawing: false,
            currentPath: [],
            selectedCannon: null,
            trenchStartPoint: null,
            infoMessage: 'Welcome! Use the tools to design your siege.',
        };

        // --- MODULAR TRENCH ALGORITHMS ---
        const TrenchAlgorithms = {
            sapperTrench: {
                Node: function(x, y, parent, g, h) { this.x=x; this.y=y; this.parent=parent; this.g=g; this.h=h; this.f=g+h; this.direction = parent ? { x: x - parent.x, y: y - parent.y } : {x:0, y:0}; },
                findPath: function(grid, start, end) {
                    let openList = []; let closedList = new Set();
                    openList.push(new this.Node(start.x, start.y, null, 0, this.heuristic(start, end)));
                    while(openList.length > 0) {
                        let lowInd = 0;
                        for(let i=1; i<openList.length; i++) { if(openList[i].f < openList[lowInd].f) { lowInd = i; } }
                        let currentNode = openList[lowInd];
                        if(currentNode.x === end.x && currentNode.y === end.y) {
                            let path = []; let curr = currentNode;
                            while(curr.parent) { path.push({x: curr.x, y: curr.y}); curr = curr.parent; }
                            return path.reverse();
                        }
                        openList.splice(lowInd, 1); closedList.add(`${currentNode.x},${currentNode.y}`);
                        let neighbors = this.getNeighbors(grid, currentNode);
                        for(let neighborPos of neighbors) {
                            if(closedList.has(`${neighborPos.x},${neighborPos.y}`)) continue;
                            let gScore = currentNode.g + 1;
                            if(grid[neighborPos.y][neighborPos.x] === 2) { gScore += 100; }
                            if(grid[neighborPos.y][neighborPos.x] === 3) { gScore -= 0.5; }
                            let hScore = this.heuristic(neighborPos, end);
                            let neighborNode = new this.Node(neighborPos.x, neighborPos.y, currentNode, gScore, hScore);
                            if (currentNode.parent && neighborNode.direction.x === currentNode.direction.x && neighborNode.direction.y === currentNode.direction.y) { neighborNode.g += 15; }
                            neighborNode.f = neighborNode.g + neighborNode.h;
                            let existingNode = openList.find(n => n.x === neighborPos.x && n.y === neighborPos.y);
                            if(!existingNode || neighborNode.g < existingNode.g) {
                                if(existingNode) { openList.splice(openList.indexOf(existingNode), 1); }
                                openList.push(neighborNode);
                            }
                        }
                    }
                    return null;
                },
                heuristic: function(pos0, pos1) { return Math.abs(pos1.x - pos0.x) + Math.abs(pos1.y - pos0.y); },
                getNeighbors: function(grid, node) {
                    let ret = []; let x = node.x; let y = node.y;
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            let newX = x + dx; let newY = y + dy;
                            if(newX >= 0 && newX < grid[0].length && newY >= 0 && newY < grid.length && grid[newY][newX] !== 1) { 
                                ret.push({x: newX, y: newY}); 
                            }
                        }
                    }
                    return ret;
                }
            },
            directApproach: {
                findPath: function(grid, start, end) {
                    let path = [];
                    let current = {x: start.x, y: start.y};
                    path.push({x: current.x, y: current.y});
                    while(current.x !== end.x || current.y !== end.y) {
                        let dx = Math.sign(end.x - current.x);
                        let dy = Math.sign(end.y - current.y);
                        current.x += dx;
                        current.y += dy;
                        if (grid[current.y] && grid[current.y][current.x] === 1) break;
                        path.push({x: current.x, y: current.y});
                    }
                    return path;
                }
            }
        };

        // --- p5.js Sketch ---
        const sketchFactory = (p) => {
            p.setup = () => {
                const container = document.getElementById('canvas-container');
                const containerSize = container.getBoundingClientRect();
                canvas = p.createCanvas(containerSize.width, containerSize.height);
                canvas.parent('canvas-container');
                p.background('#0f172a');
                p.strokeCap(p.ROUND);
                generateFort();
                updateInfoPanel();
            };

            p.draw = () => {
                p.background('#0f172a');
                drawGrid();
                drawWater();
                drawWalls();
                drawTrenches();
                drawCannons();
                
                state.cannonballs.forEach((ball, index) => {
                    ball.update();
                    ball.draw();
                    if(ball.isOffscreen()) {
                        state.cannonballs.splice(index, 1);
                    }
                });
                
                if (state.isDrawing && state.currentPath.length > 1) {
                    let color = '#94a3b8'; // Default wall color
                    if (state.currentTool === 'trench') color = '#a16207';
                    if (state.currentTool === 'water') color = '#38bdf8';
                    p.stroke(color);
                    p.strokeWeight(state.currentTool === 'water' ? 20 : (state.currentTool === 'trench' ? 6 : 10));
                    p.noFill();
                    p.beginShape();
                    state.currentPath.forEach(pt => p.vertex(pt.x, pt.y));
                    p.endShape();
                }

                if (state.trenchStartPoint) {
                    p.noFill();
                    p.stroke(255, 255, 0, 200);
                    p.strokeWeight(2);
                    p.ellipse(state.trenchStartPoint.x, state.trenchStartPoint.y, 15, 15);
                    p.line(state.trenchStartPoint.x - 10, state.trenchStartPoint.y, state.trenchStartPoint.x + 10, state.trenchStartPoint.y);
                    p.line(state.trenchStartPoint.x, state.trenchStartPoint.y - 10, state.trenchStartPoint.x, state.trenchStartPoint.y + 10);
                }
            };
            
            const drawGrid = () => {
                p.stroke(255, 255, 255, 10); p.strokeWeight(1);
                for (let x = 0; x < p.width; x += 20) { p.line(x, 0, x, p.height); }
                for (let y = 0; y < p.height; y += 20) { p.line(0, y, p.width, y); }
            }

            const drawWater = () => {
                p.stroke(14, 116, 144, 150); // a teal color
                p.fill(56, 189, 248, 100); // sky-400 with transparency
                p.strokeWeight(1);
                state.water.forEach(body => {
                    p.beginShape();
                    body.forEach(pt => p.vertex(pt.x, pt.y));
                    p.endShape(p.CLOSE);
                });
            }

            const drawWalls = () => {
                p.stroke('#64748b'); p.strokeWeight(12); p.noFill();
                state.walls.forEach(wall => {
                    p.beginShape();
                    wall.forEach(pt => p.vertex(pt.x, pt.y));
                    p.endShape(state.fortType !== 'custom' ? p.CLOSE : p.OPEN);
                });
            };

            const drawTrenches = () => {
                p.stroke('#a16207'); p.strokeWeight(8); p.noFill();
                state.trenches.forEach(trench => {
                    p.beginShape();
                    trench.forEach(pt => p.vertex(pt.x, pt.y));
                    p.endShape();
                });
            };
            
            const drawCannons = () => {
                state.cannons.forEach((cannon, index) => {
                    p.push();
                    p.translate(cannon.x, cannon.y);
                    
                    if(state.selectedCannon === index) {
                        p.noFill();
                        p.stroke('#0ea5e9');
                        p.strokeWeight(2);
                        p.ellipse(0, 0, 45, 45);
                    }

                    p.rotate(p.radians(cannon.angle));
                    p.fill('#334155'); p.noStroke(); p.ellipse(-5, 0, 30, 30);
                    p.fill('#1e293b'); p.rect(0, -4, 25, 8);
                    p.pop();
                });
            };

            p.mousePressed = () => {
                if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) return;
                
                if (state.currentTool === 'select') {
                    let clickedOnCannon = false;
                    for (let i = state.cannons.length - 1; i >= 0; i--) {
                        const cannon = state.cannons[i];
                        if (p.dist(p.mouseX, p.mouseY, cannon.x, cannon.y) < 20) {
                            state.selectedCannon = i;
                            updateSlidersForSelectedCannon();
                            setInfo(`Cannon ${i+1} selected. Adjust its settings.`);
                            clickedOnCannon = true;
                            break;
                        }
                    }
                    if (!clickedOnCannon) {
                        state.selectedCannon = null;
                        setInfo('No cannon selected. Click one to modify it.');
                    }
                } else if (state.currentTool === 'trench' || state.currentTool === 'wall' || state.currentTool === 'water') {
                    state.isDrawing = true; state.currentPath = [{ x: p.mouseX, y: p.mouseY }];
                } else if (state.currentTool === 'cannon') {
                    const angle = parseFloat(document.getElementById('cannon-angle').value);
                    const power = parseFloat(document.getElementById('cannon-power').value);
                    state.cannons.push({x: p.mouseX, y: p.mouseY, angle: angle, power: power});
                    setInfo(`Cannon placed. Place more or fire them all!`);
                } else if (state.currentTool === 'generateTrenchStart') {
                    state.trenchStartPoint = {x: p.mouseX, y: p.mouseY};
                    setTool('generateTrenchEnd');
                } else if (state.currentTool === 'generateTrenchEnd') {
                    p.runTrenchGeneration(state.trenchStartPoint, {x: p.mouseX, y: p.mouseY});
                    state.trenchStartPoint = null;
                    setTool('select');
                } else if (state.currentTool === 'remove') {
                    p.removeClosestElement();
                }
            };

            p.mouseDragged = () => { if (state.isDrawing) state.currentPath.push({ x: p.mouseX, y: p.mouseY }); };

            p.mouseReleased = () => {
                if (state.isDrawing) {
                    state.isDrawing = false;
                    if (state.currentPath.length > 1) {
                        if (state.currentTool === 'trench') state.trenches.push(state.currentPath);
                        else if (state.currentTool === 'wall') state.walls.push(state.currentPath);
                        else if (state.currentTool === 'water') state.water.push(state.currentPath);
                    }
                    state.currentPath = [];
                }
            };

            p.windowResized = () => {
                const container = document.getElementById('canvas-container');
                const containerSize = container.getBoundingClientRect();
                p.resizeCanvas(containerSize.width, containerSize.height);
            };

            class Cannonball {
                constructor(x, y, angle, power) {
                    this.pos = p.createVector(x, y);
                    this.vel = p5.Vector.fromAngle(p.radians(angle));
                    this.vel.mult(power * 0.2);
                    this.gravity = p.createVector(0, 0.2);
                    this.path = [];
                    this.stopped = false;
                }
                update() {
                    if (this.stopped) return;
                    this.path.push(this.pos.copy());
                    this.vel.add(this.gravity);
                    this.pos.add(this.vel);
                    this.checkCollisions();
                }
                checkCollisions() {
                    if (this.path.length < 2) return;
                    const lastPos = this.path[this.path.length-2];
                    const currentPos = this.pos;
                    const checkLineCollision = (lines) => {
                         for (const line of lines) {
                            for (let i = 0; i < line.length - 1; i++) {
                                const pt1 = line[i]; const pt2 = line[i+1];
                                if (this.lineIntersect(lastPos.x, lastPos.y, currentPos.x, currentPos.y, pt1.x, pt1.y, pt2.x, pt2.y)) return true;
                            }
                        }
                        return false;
                    }
                    if (checkLineCollision(state.walls) || checkLineCollision(state.water)) { this.stopped = true; this.impactEffect(); } 
                    else if (checkLineCollision(state.trenches)) { this.stopped = true; this.impactEffect(); }
                }
                lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                    const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4); if (den == 0) return false;
                    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
                    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;
                    return t > 0 && t < 1 && u > 0 && u < 1;
                }
                impactEffect() { p.fill(251, 146, 60, 150); p.noStroke(); p.ellipse(this.pos.x, this.pos.y, 30, 30); }
                draw() {
                    p.noStroke(); p.fill(255); p.ellipse(this.pos.x, this.pos.y, 10, 10);
                    p.stroke(255, 0, 0, 100); p.strokeWeight(2); p.noFill(); p.beginShape();
                    this.path.forEach(pt => p.vertex(pt.x, pt.y)); p.endShape();
                }
                isOffscreen() { return (this.pos.y > p.height || this.pos.x < 0 || this.pos.x > p.width); }
            }

            p.fireAllCannons = () => {
                if (state.cannons.length > 0) {
                    state.cannonballs = []; 
                    state.cannons.forEach(cannon => {
                        state.cannonballs.push(new Cannonball(cannon.x, cannon.y, cannon.angle, cannon.power));
                    });
                    setInfo(`Volley of ${state.cannons.length} fired!`);
                } else { setInfo('You must place cannons first!'); }
            };

            p.runTrenchGeneration = (startCoords, endCoords) => {
                const selectedAlgorithm = document.getElementById('algorithm-select').value;
                const algorithm = TrenchAlgorithms[selectedAlgorithm];
                if (!algorithm) {
                    setInfo(`Error: Algorithm '${selectedAlgorithm}' not found.`);
                    return;
                }
                setInfo('Calculating path...');
                setTimeout(() => {
                    const gridSize = 20; const gridW = Math.floor(p.width/gridSize); const gridH = Math.floor(p.height/gridSize);
                    let grid = Array(gridH).fill(0).map(() => Array(gridW).fill(0));
                    
                    const markObstacles = (paths) => {
                        paths.forEach(path => {
                            for (let i = 0; i < path.length - 1; i++) {
                                let ptsOnLine = p.dist(path[i].x, path[i].y, path[i+1].x, path[i+1].y) / 5;
                                for(let j=0; j <= ptsOnLine; j++) {
                                    let x = p.lerp(path[i].x, path[i+1].x, j/ptsOnLine); let y = p.lerp(path[i].y, path[i+1].y, j/ptsOnLine);
                                    let gx = Math.floor(x/gridSize); let gy = Math.floor(y/gridSize);
                                    if (grid[gy] && grid[gy][gx] !== undefined) grid[gy][gx] = 1;
                                }
                            }
                        });
                    }
                    markObstacles(state.walls);
                    markObstacles(state.water);

                    const dangerRadius = 5;
                    state.cannons.forEach(cannon => {
                        const gx = Math.floor(cannon.x / gridSize); const gy = Math.floor(cannon.y / gridSize);
                        for(let y = gy - dangerRadius; y <= gy + dangerRadius; y++) {
                            for(let x = gx - dangerRadius; x <= gx + dangerRadius; x++) {
                                if(x >= 0 && x < gridW && y >= 0 && y < gridH) {
                                    if(p.dist(x, y, gx, gy) <= dangerRadius && grid[y][x] === 0) { grid[y][x] = 2; }
                                }
                            }
                        }
                    });
                    state.trenches.forEach(trench => {
                         for (let i = 0; i < trench.length - 1; i++) {
                            let ptsOnLine = p.dist(trench[i].x, trench[i].y, trench[i+1].x, trench[i+1].y) / 5;
                            for(let j=0; j <= ptsOnLine; j++) {
                                let x = p.lerp(trench[i].x, trench[i+1].x, j/ptsOnLine); let y = p.lerp(trench[i].y, trench[i+1].y, j/ptsOnLine);
                                let gx = Math.floor(x/gridSize); let gy = Math.floor(y/gridSize);
                                if (grid[gy] && grid[gy][gx] === 0) grid[gy][gx] = 3;
                            }
                        }
                    });
                    const start = { x: Math.floor(startCoords.x / gridSize), y: Math.floor(startCoords.y / gridSize) };
                    const end = { x: Math.floor(endCoords.x / gridSize), y: Math.floor(endCoords.y / gridSize) };

                    if (grid[start.y] && grid[start.y][start.x] === 1) { setInfo('Cannot start trench inside an obstacle!'); return; }
                    if (grid[end.y] && grid[end.y][end.x] === 1) { setInfo('Cannot end trench inside an obstacle!'); return; }
                    
                    const path = algorithm.findPath(grid, start, end);
                    if (path) {
                        const canvasPath = path.map(node => ({ x: node.x*gridSize+gridSize/2, y: node.y*gridSize+gridSize/2 }));
                        state.trenches.push(canvasPath);
                        setInfo('Trench path generated!');
                    } else { setInfo('Could not find a path!'); }
                }, 50);
            };
            
            p.removeClosestElement = () => {
                let closest = { distSq: Infinity, type: null, index: -1 };
                const clickPos = p.createVector(p.mouseX, p.mouseY);

                // Check cannons
                state.cannons.forEach((cannon, index) => {
                    const dSq = p.dist(clickPos.x, clickPos.y, cannon.x, cannon.y) ** 2;
                    if (dSq < closest.distSq) {
                        closest = { distSq: dSq, type: 'cannons', index: index };
                    }
                });

                // Check paths
                const findClosestInPaths = (paths, type) => {
                    paths.forEach((path, index) => {
                        for(let i = 0; i < path.length - 1; i++) {
                            const dSq = distToSegment(clickPos, path[i], path[i+1]);
                            if (dSq < closest.distSq) {
                                closest = { distSq: dSq, type: type, index: index };
                            }
                        }
                    });
                };
                findClosestInPaths(state.trenches, 'trenches');
                findClosestInPaths(state.walls, 'walls');
                findClosestInPaths(state.water, 'water');
                
                // Use a single threshold, e.g., 20px
                if (closest.distSq < 400) { 
                    const typeName = closest.type.slice(0, -1); // make singular
                    if (closest.type === 'cannons') {
                        if (state.selectedCannon === closest.index) {
                            state.selectedCannon = null;
                        } else if (state.selectedCannon > closest.index) {
                            state.selectedCannon--;
                        }
                    }
                    state[closest.type].splice(closest.index, 1);
                    setInfo(`${typeName.charAt(0).toUpperCase() + typeName.slice(1)} removed.`);
                } else {
                    setInfo('Nothing to remove. Click closer to an element.');
                }
            };

            function distSq(v, w) { return p.pow(v.x - w.x, 2) + p.pow(v.y - w.y, 2) }
            function distToSegment(click, v, w) {
                const l2 = distSq(v, w);
                if (l2 == 0) return distSq(click, v);
                let t = ((click.x - v.x) * (w.x - v.x) + (click.y - v.y) * (w.y - v.y)) / l2;
                t = p.max(0, p.min(1, t));
                return distSq(click, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
            }
        };
        
        // --- Helper Functions and Event Listeners ---
        function setTool(tool) {
            state.currentTool = tool;
            document.querySelectorAll('#controls .btn').forEach(b => {
                b.classList.remove('btn-active');
                b.classList.remove('btn-danger-active');
            });
            
            let elementToActivate; 
            if (tool === 'generateTrenchStart' || tool === 'generateTrenchEnd') {
                elementToActivate = document.getElementById('generate-trench-button');
            } else {
                elementToActivate = document.getElementById(`tool-${tool}`);
            }

            if (elementToActivate) {
                if (tool === 'remove') {
                    elementToActivate.classList.add('btn-danger-active');
                } else {
                    elementToActivate.classList.add('btn-active');
                }
            }
            
            if (tool === 'generateTrenchStart') { setInfo('Click a starting point for the trench.'); }
            else if (tool === 'generateTrenchEnd') { setInfo('Click an ending point for the trench.'); }
            else if (tool === 'wall' && state.fortType !== 'custom') {
                state.fortType = 'custom'; document.getElementById('fort-select').value = 'custom'; state.walls = [];
                setInfo('Switched to Custom fort. Draw your walls!');
            } else { 
                setInfo(`Tool selected: ${tool}.`); 
            }
        }
        
        function setInfo(message) { state.infoMessage = message; updateInfoPanel(); }
        function updateInfoPanel() { document.getElementById('info-panel').textContent = state.infoMessage; }
        
        function updateSlidersForSelectedCannon() {
            if (state.selectedCannon !== null && state.cannons[state.selectedCannon]) {
                const cannon = state.cannons[state.selectedCannon];
                document.getElementById('cannon-angle').value = cannon.angle;
                document.getElementById('angle-value').textContent = Math.round(cannon.angle);
                document.getElementById('cannon-power').value = cannon.power;
                document.getElementById('power-value').textContent = cannon.power;
            }
        }

        function generateFort() {
            state.walls = [];
            const w = sketch ? sketch.width : document.getElementById('canvas-container').getBoundingClientRect().width;
            const h = sketch ? sketch.height : document.getElementById('canvas-container').getBoundingClientRect().height;
            const cx = w / 2; const cy = h / 2; let size = Math.min(w, h) * 0.3;
            switch (state.fortType) {
                case 'square': state.walls.push([ { x:cx-size/2, y:cy-size/2 }, { x:cx+size/2, y:cy-size/2 }, { x:cx+size/2, y:cy+size/2 }, { x:cx-size/2, y:cy+size/2 } ]); break;
                case 'circular': let circlePoints = []; for (let a = 0; a <= 360; a += 10) { let rad = p5.prototype.radians(a); circlePoints.push({ x: cx + (size/2) * Math.cos(rad), y: cy + (size/2) * Math.sin(rad) }); } state.walls.push(circlePoints); break;
                case 'star':
                     let starPoints = []; const outerRadius = size / 2; const innerRadius = size / 4; const points = 5;
                     for (let i = 0; i <= points * 2; i++) {
                         let radius = i % 2 === 0 ? outerRadius : innerRadius;
                         let angle = p5.prototype.radians(i * (360 / (points * 2)) - 90);
                         starPoints.push({ x: cx + radius * Math.cos(angle), y: cy + radius * Math.sin(angle) });
                     }
                     state.walls.push(starPoints);
                    break;
            }
        }

        function resetSimulation() {
            state.trenches = []; state.walls = []; state.water = []; state.cannons = []; state.cannonballs = []; state.selectedCannon = null; state.trenchStartPoint = null;
            if (state.fortType !== 'custom') { generateFort(); } else { state.walls = []; }
            setInfo('Simulation reset. Rebuild your defenses!');
            setTool('select');
        }

        document.addEventListener('DOMContentLoaded', () => {
            sketch = new p5(sketchFactory);
            
            document.getElementById('tool-select').addEventListener('click', () => setTool('select'));
            document.getElementById('tool-trench').addEventListener('click', () => setTool('trench'));
            document.getElementById('tool-wall').addEventListener('click', () => setTool('wall'));
            document.getElementById('tool-cannon').addEventListener('click', () => setTool('cannon'));
            document.getElementById('tool-water').addEventListener('click', () => setTool('water'));
            document.getElementById('tool-remove').addEventListener('click', () => setTool('remove'));
            document.getElementById('fort-select').addEventListener('change', (e) => {
                state.fortType = e.target.value; resetSimulation();
                setInfo(`Loaded ${e.target.options[e.target.selectedIndex].text}. Start designing!`);
            });
            document.getElementById('cannon-angle').addEventListener('input', (e) => {
                const value = e.target.value;
                document.getElementById('angle-value').textContent = value;
                if (state.selectedCannon !== null && state.cannons[state.selectedCannon]) {
                    state.cannons[state.selectedCannon].angle = parseFloat(value);
                }
            });
            document.getElementById('cannon-power').addEventListener('input', (e) => {
                const value = e.target.value;
                document.getElementById('power-value').textContent = value;
                 if (state.selectedCannon !== null && state.cannons[state.selectedCannon]) {
                    state.cannons[state.selectedCannon].power = parseFloat(value);
                }
            });
            document.getElementById('fire-button').addEventListener('click', () => sketch.fireAllCannons());
            document.getElementById('reset-button').addEventListener('click', () => resetSimulation());
            document.getElementById('generate-trench-button').addEventListener('click', () => {
                setTool('generateTrenchStart');
            });

            setTool('select');
        });
    </script>
</body>
</html>
